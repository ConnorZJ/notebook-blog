---
title: Redis的数据结构
date: 2021-04-11
categories: redis
---

不管是学习过redis的同学，或者是使用过redis的同学，都应该知道redis的**5种**数据类型：

- String 字符串类型
- Hash 散列值（哈希、键值对）
- List 链表
- Set 集合
- Sort-Set 有序集合（zset）

比如说现在有个问题，是问在redis中使用``strlen``命令查看一个key对应的字符串类型的value的长度时，这个命令的时间复杂度是多少？

众所周知，redis是由C语言编写的，了解C语言的同学知道，在C中，字符串并不会记录自身的长度，所有只能通过遍历整个字符串的方式，对每一个遇到的字符进行计数，直到遇到代表字符串终止的字符为止，这个过程的时间复杂度是O(N)。

但其实``strlen``命令的时间复杂度并不是O(N)，接下来将会通过介绍redis在C中的数据结构，来解答一下这个问题的正确回答！

## SDS 简单动态字符串

### 概述

对于redis的字符串类型来说，底层并没有直接使用C语言中的字符串来表示，而是自己构建了一个数据结构叫做简单动态字符串（Simple Dynamic String，SDS）的抽象类型。

比如说现在在客户端中执行以下命令：

```bash
127.0.0.1:6379> set msg "hello world"
OK
```

那么在redis的对应的数据库中创建两个SDS对象，分别是底层保存**"msg"**的SDS和底层保存**"hello world"**的两个对象。

接下来看看为何要创建一个SDS的抽象对象来表示字符串。

### SDS的定义

对于SDS类型来说，它的结构如下所示：

```c
struct sdshdr {
    // 用来记录buf数组已经使用了的长度，也表示此SDS对象所保存的字符串长度
    int len;
    // 用来表示buf数组中还未使用的长度
    int free;
    // 用来存储字符串
    char buf[];
}
```

比如说现在有个存了Redis字符串的SDS对象，这个对象的结构如下所示：

<img src="https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/20210411224855.png" style="zoom:50%;" />

在这个SDS的示例中：

- free的属性为0，表示这个SDS对象没有未分配的空间了
- len的属性为5，表示这个SDS对象存储的字符串的长度为5
- buf指向了一个char类型的数组，这个数组的长度为6个字节，前面5个字节分别保存了'R'、'e'、'd'、'i'、's'这5个字符，最后一个则保存了'\0'这个字符，在C语言中，字符'\0'表示空字符

###  使用SDS的好处

#### 1. 常数复杂度获取字符串长度

我们通过了解了SDS的结构，知道了里面有个`len`属性用来表示存储的字符串长度，那么如果我们想获取这个SDS的对应的字符串长度，只需要拿到这个对象的`len`属性的值就可以了。

所以这也回答了我们开头所提到的那个问题，想要使用`strlen`命令获取对应的value的长度，就相当于找到这个value对应的SDS对象的`len`的属性值，这个过程就是一个复杂度为**O(1)**的过程。所以即便我们在客户端中对一个长度非常非常长的字符串反复执行`strlen`命令，这也不会造成系统的性能问题。

#### 2. 杜绝缓冲区溢出

因为在C中的字符串是不会记录自身长度的，所以在操作过程中可能会发生缓冲区溢出的现象。

比如说现在有两个字符串s1和s2，分别为"Redis"和"MongoDB"，这两个字符串在内存中是紧紧挨着的，如下所示：

<img src="https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/20210411232343.png" style="zoom:50%;" />

假如我现在要将s1字符串替换为"Redis Cluster"，但是没有给s1分配足够的内存空间，那么就会发生以下情况：

<img src="https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/20210411232518.png" style="zoom:50%;" />

如图所示，保存新的字符串的时候，s2就会被错误的修改了。

而在SDS对象中，就不会发生这种事情，比如现在有个存储了Redis的SDS对象：

<img src="https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/20210411232730.png" style="zoom:50%;" />

我现在想要修改这个对象中的值为"Redis Cluster"，那么在执行之前，会先判断长度是否够用，如果够用，则直接将" Cluster"拼接到buf数组之中，如果不够，则会先为buf数组分配足够的空间，再进行拼接的操作。

<img src="https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/20210411233027.png" style="zoom:50%;" />

在图中能够看到，现在保存的"Redis Cluster"的长度为13，所以len属性的值为13，不过free的属性值也被修改成了13，这其实是有原因的。

#### 3. 减少改变字符串长度所带来的内存分配次数

如上面一个小结的例子来说，假如我要修改SDS的存储的字符串长度来说，有以下两种情况：

- 如果是增加字符串长度的操作，那么在每次操作之前，都要先判断剩余长度是否足够新的字符串拼接进来，如果不执行这一步，就有可能导致缓冲区溢出。
- 如果是减少字符串长度的操作，那么在每次操作之后，都要将剩余的空间回收，如果不执行这一步，就有可能导致内存泄漏。

所以对于以上两种情况，分别有针对性的方案来应对。

##### 空间预分配

如果我们对一个字符串进行增加操作，假如每次都给这个buf数组分配的长度恰好等于新的字符串的长度，比如说我要从buf[6]{'R','e','d','i','s','\0'}分配到buf[13]{'R','e','d','i','s',' ','C','l','u','s','t','e','r','\0'}，恰好给buf分配长度为13，那么在以后的增加字符串的过程中，每次都要额外分配空间再拼接，而redis一般都用在性能要求比较高的场景，频繁的分配空间的话，可能会对性能造成影响。

为了避免这种情况发生，redis采取了一下两种方案：

- 如果修改之后的字符串长度小于1MB（len的值），那么就给buf再额外分配与len的值相同大小的**未使用空间**，那么len的值将会和free的值相同，并且buf的长度将会等于(len + free) + 1（额外的1个字节用来保存结尾的空字符）。
- 如果修改之后的字符串长度大于等于1MB的话，那么就给buf再分配1MB的未使用空间，比如len的值将会等于30MB，那么free的值将会为1MB，buf的长度将会等于30MB + 1MB + 1byte

##### 惰性空间释放

对于减少字符串的操作来说，每次减少之后，都去再分配释放空间，也可能造成性能问题。

所以在减少字符串之后，将减少的那部分的长度值赋给free，并且修改len的值为修改后的长度值，buf数组则只保存修改后的值，但是长度不变。因为读取SDS的buf值的时候是通过len来截取的，所以也不会出现误读的情况。

假如值为"Redis Cluster"的SDS对象需要将字符串修改为"Redis"，那么修改之后，free的值为8，len的值为5，buf的长度依旧为14。如果以后又对这个SDS对象进行增加字符串操作的话，因为free还有空间，足以再拼接8个长度的字符串，如果需要拼接的新字符串不超过8的话，就不用再进行分配空间操作了，只需要修改free和len的值即可。

SDS也提供了相应的API，在有需要的时候，也可以自主调用，释放那些没有使用的空间，所以不用担心内存泄漏的问题。

#### 4. 二进制安全

在C中的普通字符串只能包含符合规范编码的字符（比如ASCII码），而且在除了末尾的`'\0'`空字符之外，字符串中不能包含任何的空字符。这样就导致了普通字符串只能保存文本数据，但是像图片或者音频之类的二进制文件就不能保存下来。

但是在SDS中是使用buf数组来保存数据，这个buf数组一般称之为字节数组，其原因就是因为可以通过buf数组来保存像二进制文件之类的数据格式，以一个一个的字节存储起来。在写入的时候是什么样子，那么通过len属性读出来的时候，也就是什么样子。不会像普通文本字符串那样有所限制，所以说它是二进制安全的。

#### 5. 兼容部分C字符串函数

既然SDS是被创建的一种新的数据结构，那么对其处理的话就需要由程序员去编写对应的新的方法。但是在某些SDS中的buf数组中，最后一位都是`'\0'`，这是为了让这些保存文本的SDS能够重用C字符串的函数。通过遵循C字符串以空字符结尾的惯例，SDS可以在有需要的时候重用<string.h>函数库（一种C语言中的函数方法文件，类似于Java中的jar包），从而避免了不必要的代码重复。

### 总结

对C语言字符串和SDS之间的区别进行总结

| C字符串                                | SDS                                     |
| :------------------------------------- | --------------------------------------- |
| 获取字符串长度的时间复杂度为O(N)       | 获取字符串长度的时间复杂度为O(1)        |
| API是不安全的，可能会造成缓冲区溢出    | 通过len和free，能有效控制缓冲区溢出问题 |
| 修改字符串长度N次必定要分配N次内存空间 | 修改字符串长度N次最多分配N次内存空间    |
| 只能保存文本数据                       | 通过buf数组还能够保存二进制数据         |
| 可以使用<string.h>库中的所有函数       | 只能使用<string.h>库中的部分函数        |

## 链表

### 概述

链表在数据结构中是非常重要的一环，但是在C语言中并没有内置一个这种的结构，所以redis就自己定义了一种链表的数据结构。

### 链表的定义

链表显而易见是由多个链表节点一一连接构成的，每个链表节点的定义如下：

```c
typedef struct listNode {
    // 前置节点
    struct listNode *prev;
    // 后置节点
    struct listNode *next;
    // 节点的值
    void *value;
}
```

从以上结构体能够看书，每个链表节点不仅有该值属性，还有着前指针和后指针的，所以这些链表节点组成的链表是一个**双向链表**。而且头节点的prev和尾结点的next一般都是`null`，遍历该链表的时候，只要遍历到`null`即为终止，所以不会出现循环链表的情况。

<img src="https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/20210413234130.png" style="zoom:50%;" />

虽然通过双向链表访问节点数据是非常方便的，但是redis还创建了另一个结构体，定义如下所示：

```c
typedef struct list {
    // 表头节点指针
    listNode *head;
    // 表尾节点指针
    listNode *tail;
    // 链表所包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup) (void *ptr);
    // 节点值释放函数
    void *(*free) (void *ptr);
    // 节点值对比函数
    int (*match) (void *ptr, void *key);
} list;
```

以上结构体表示list对象持有着链表的头节点和尾节点，所以通过list对象查找链表的头和尾的时间复杂度是O(1)。而且list对象还保存了链表对应的节点数量，那么查找链表的长度的时间复杂度也是O(1)。

剩余的三个函数分别是节点值复制函数、释放函数和对比函数。就是list对应的链表节点在实现对应的操作时，会走对应的函数。

<img src="https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/20210413234934.png" style="zoom:50%;" />

### 链表的特性

1. 双端：链表节点带有prev和next指针，所以通过某个节点获取前置节点或后置节点的时间复杂度都是O(1)；
2. 无环：头部节点的prev和尾部节点的next都是`null`，所以遍历链表只需要判断当访问到了`null`的时候即为终止；
3. 带表头指针和表尾指针：通过list对象获取头节点和尾结点的时间复杂度是O(1)；
4. 带链表长度计数器：通过list对象的len属性获取链表的长度的时间复杂度是O(1)；
5. 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。