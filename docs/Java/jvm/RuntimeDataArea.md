---
title: 运行时数据区
date: 2020-12-07
categories:
 - JVM
tags:
 - JVM
---

> Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。

## 运行时数据区详细图例

![](https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic方法区详细图.png)

## pc寄存器（程序计数器）

由于Java虚拟机支持多条线程同时执行，在任意时刻，一条线程只会执行一个方法。在程序切换的同时，为了让之前中断的线程恢复到正确的位置，需要将线程执行到哪儿的内存地址给记录下来。**每一条Java虚拟机线程都有自己的pc寄存器**，各个pc寄存器之间互不影响。因此，pc寄存器是用来记录当前线程执行到的内存地址的，储存下一条指令的地址，然后由执行引擎读取下一条指令。

pc寄存器是一块很小的内存空间，几乎可以忽略不计。也是运行最快的存储区域。在JVM规范之中，每个线程都有它自己的程序计数器，是线程私有的，生命周期和线程的生命周期保持一致。任何时间一个线程只会执行一个方法，也就是所谓的当前方法。程序计数器会记录当前线程正在执行的方法的JVM指令地址，如果执行的是本地方法，则记录的是未指定值（undefined）

它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是改变这个计数器的值来选取下一条需要执行的字节码指令。它是唯一一个在JVM规范中没有规定任何OOM情况的区域。

### pc寄存器如何使用的呢？

之前说到，pc寄存器是记录当前线程执行的内存地址，存储下一条指令地址，这个是什么意思呢？

接下来看看代码，让代码告诉我们是为什么！

```java
public class PcRegisterTest {

    public static void main(String[] args) {
        int a = 100;
        int b = 200;
        int c = a + b;
    }

}
```

首先写一个简单的类，其中包括一个main方法，里面定义三个变量，分别是a,b,c。接下来编译这个java文件生成class文件，然后在生成的class文件的路径下使用``javap -v PcRegisterTest``命令，这个命令是能够把编译后的字节码文件反编译，让我们能够看到其内部是如何实现的！

```
Classfile /Users/connor/code/out/production/com/xzj/PcRegisterTest.class
-------------------部分省略---------------
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        100
         2: istore_1
         3: sipush        200
         6: istore_2
         7: iload_1
         8: iload_2
         9: iadd
        10: istore_3
        11: return
-------------------部分省略---------------
```

以上就是截取了部分反编译后的文件内容，从其中能看出来，这个是main方法体中的实现。在第8行使用索引为0标注了指令``bipush``，表示将常量100压入操作数栈中。然后索引为2的指令为``istore_1``，表示将操作数栈弹出，保存到局部变量表的第1个位置。索引3和6同理，表示将常量200入栈，然后出栈保存到局部变量表的第2个位置。接着索引7和8分别表示将第一个和第二个位置的变量加载出来，在索引为9的指令表示将之前两个加载出来的数进行相加操作，索引10的指令表示将相加的得数保存到局部变量表的第3个位置。最终返回。

如果看懂了上面的反编译文件的过程，就能很容易理解pc寄存器在其中是怎么工作的：**pc寄存器会保存下一条待执行的指令的地址**。假如线程执行到了索引为2的地方，pc寄存器就会记录地址2，并且保存接下来要执行的指令地址为3，接下来执行引擎就是读取pc寄存器储存的指令地址，然后执行地址3对应的``sipush``指令。而此时pc寄存器也将会继续保存下面一个指令地址，即地址6。接下来执行引擎又会读取地址6对应的``istore_2``指令。。。。。

### pc寄存器的相关问题

- 使用pc寄存器存储字节码地址有什么用呢？

  当CPU在并发的执行多个线程的时候，会高速的进行上下文切换，在从A线程切换到B线程再切换回A的时候，需要一个东西去记录切换之前A已经执行到哪里了，以便于接着执行。

- 为什么pc寄存器是线程私有的？

  因为在线程切换的时候，如果pc寄存器不是线程私有的话，就会产生多个线程被pc寄存器记录到了同一个地址。如果pc寄存器是线程私有的话，那么每一条线程执行的位置都是清晰明了的，这样一来，各个线程之间相互独立，不出出现互相干扰的情况。



## Java虚拟机栈

Java虚拟机栈（Java Virtual Machine Stack），也称Java栈。每个线程创建的时候都会创建一个Java虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。

与pc寄存器相同的是，Java虚拟机栈的生命周期和线程保持一致。

Java虚拟机栈的作用是：主管Java程序的运行，它保存方法的局部变量（8中基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回

### Java虚拟机栈的特点（优点）

- 栈式一种快速有效的分配存储方式，访问速度仅次于pc寄存器。
- JVM直接对Java栈的操作只有两个：
  - 每个方法执行，伴随着入栈
  - 执行结束之后出栈
- 对于栈来说不存在垃圾回收问题

### Java中可能出现的异常

Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。

- 如果采用的是固定大小的Java虚拟机栈，那每一次线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机栈将会抛出一个StackOverflowError异常。
- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。

可以使用``-Xss``来指定Java栈的大小

### 栈中存储着什么

- 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。
- 在这个线程上正在执行的每个方法都各自对应着一个栈帧（Stack Frame）。
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

### 栈运行原理

- JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则
- 在一条活动的线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为**当前栈帧**（Current Frame），与当前栈帧对应的方法就是**当前方法**（Current  Method），定义这个方法的类就是**当前类**（Current Class）
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在站的顶端，成为新的当前帧
- 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧
- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
- Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出

## 本地方法栈（Native Method Stack）

- Java虚拟机用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用
- 本地方法栈也是线程私有的
- 允许被实现成固定或者是可动态扩展的内存大小
  - 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常
  - 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，后者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常
- 本地方法是使用C/C++语言实现的
- 它的具体做法是Native Method Stack中登记native方法，在执行引擎执行时加载本地方法库

## 堆（Heap）

### 堆的核心概述

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域
- Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间
  - 堆的内存的大小是可以调节的
- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer， TLAB）
- **几乎所有的对象实例以及数组**都应当在运行时分配在堆上，极少数分配会在栈上分配
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除
- 堆是GC执行垃圾回收的重点区域

### 堆的内存细分

现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：**新生代**，**老年代**，**元空间**（jkd7及以前成为永久代，**不在堆中**），其中新生代又被划分为**Eden**区和**Survivor**区。

### 堆空间大小设置

通过使用``-Xms``和``-Xmx``进行设置

- ``-Xms``用于表示堆区的**起始内存**，等价于``-XX:InitialHeapSize``
- ``-Xmx``则用于表示堆区的最大内存，等价于``-XX:MaxHeapSize``

一旦堆区中的内存大小超过``-Xmx``所指定的最大内存时，将会抛出OutOfMemoryError异常，通常会将``-Xms``和``-Xmx``两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能

> 默认情况下，初始内存大小：物理电脑内存大小/64
>
>   					  	最大内存大小：物理电脑内存大小/4

