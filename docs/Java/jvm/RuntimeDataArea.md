---
title: 运行时数据区
date: 2020-12-07
categories:
 - JVM
tags:
 - JVM
---

> Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。

## 方法区详细图例

![](https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic方法区详细图.png)

## pc寄存器（程序计数器）

由于Java虚拟机支持多条线程同时执行，在任意时刻，一条线程只会执行一个方法。在程序切换的同时，为了让之前中断的线程恢复到正确的位置，需要将线程执行到哪儿的内存地址给记录下来。**每一条Java虚拟机线程都有自己的pc寄存器**，各个pc寄存器之间互不影响。因此，pc寄存器是用来记录当前线程执行到的内存地址的，储存下一条指令的地址，然后由执行引擎读取下一条指令。

pc寄存器是一块很小的内存空间，几乎可以忽略不计。也是运行最快的存储区域。在JVM规范之中，每个线程都有它自己的程序计数器，是线程私有的，生命周期和线程的生命周期保持一致。任何时间一个线程只会执行一个方法，也就是所谓的当前方法。程序计数器会记录当前线程正在执行的方法的JVM指令地址，如果执行的是本地方法，则记录的是未指定值（undefined）

它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是改变这个计数器的值来选取下一条需要执行的字节码指令。它是唯一一个在JVM规范中没有规定任何OOM情况的区域。

### pc寄存器如何使用的呢？

之前说到，pc寄存器是记录当前线程执行的内存地址，存储下一条指令地址，这个是什么意思呢？

接下来看看代码，让代码告诉我们是为什么！

```java
public class PcRegisterTest {

    public static void main(String[] args) {
        int a = 100;
        int b = 200;
        int c = a + b;
    }

}
```

首先下一个简单的类，其中包括一个main方法，里面定义三个变量，分别是a,b,c。接下来编译这个java文件生成class文件，然后再生成的class文件的路径下使用``javap -v PcRegisterTest``命令，这个命令是能够把编译后的字节码文件反编译，让我们能够看到其内部是如何实现的！

```
Classfile /Users/connor/code/out/production/com/xzj/PcRegisterTest.class
-------------------部分省略---------------
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        100
         2: istore_1
         3: sipush        200
         6: istore_2
         7: iload_1
         8: iload_2
         9: iadd
        10: istore_3
        11: return
-------------------部分省略---------------
```

以上就是截取了部分反编译后的文件内容，从其中能看出来，这个是main方法体中的实现。在第8行使用索引为0标注了指令``bipush``，表示将常量100压入操作数栈中。然后索引为2的指令为``istore_1``，表示将操作数栈弹出，保存到局部变量表的第1个位置。索引3和6同理，表示将常量200入栈，然后出栈保存到局部变量表的第2个位置。接着索引7和8分别表示将第一个和第二个位置的变量加载出来，在索引为9的指令表示将之前两个加载出来的数进行相加操作，索引10的指令表示将相加的得数保存到局部变量表的第3个位置。最终返回。

如果看懂了上面的反编译文件的过程，就能很容易理解pc寄存器在其中是怎么工作的：**pc寄存器会保存下一条待执行的指令的地址**。假如线程执行到了索引为2的地方，pc寄存器就会记录地址2，并且保存接下来要执行的指令地址为3，接下来执行引擎就是读取pc寄存器储存的指令地址，然后执行地址3对应的``sipush``指令。而此时pc寄存器也将会继续保存下面一个指令地址，即地址6。接下来执行引擎又会读取地址6对应的``istore_2``指令。。。。。

### pc寄存器的相关问题

- 使用pc寄存器存储字节码地址有什么用呢？

  当CPU在并发的执行多个线程的时候，会高速的进行上下文切换，在从A线程切换到B线程再切换回A的时候，需要一个东西去记录切换之前A已经执行到哪里了，以便于接着执行。

- 为什么pc寄存器是线程私有的？

  因为在线程切换的时候，如果pc寄存器不是线程私有的话，就会产生多个线程被pc寄存器记录到了同一个地址。如果pc寄存器是线程私有的话，那么每一条线程执行的位置都是清晰明了的，这样一来，各个线程之间相互独立，不出出现互相干扰的情况。



## Java虚拟机栈



