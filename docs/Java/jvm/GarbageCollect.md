---
title: 垃圾回收
date: 2021-01-07
categories:
 - JVM
tags:
 - JVM
---

## 垃圾回收概述

### 什么是垃圾？

在JVM中，垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占用的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致**内存溢出**。

### 为什么需要垃圾回收

1. 对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。
2. 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。
3. 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有垃圾回收就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。

## 判断垃圾的两种算法

在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中**哪些是存活对象，哪些是已经死亡**的对象。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们称之为**垃圾标记阶段**。

那么在JVM中如何标记一个对象是死亡的呢？简单来说，当一个**对象已经不再被任何的存活对象继续引用**时，就可以宣判为已经死亡。

判断对象存活一般有两种方式：**引用计数算法**和**可达性分析算法**。

### 引用计数算法

引用计数算法（Reference Counting），对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。

对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就+1；当引用失效时，引用计数器就-1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可以进行回收。

#### 引用计数算法的优缺点

优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。

缺点：

- 需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
- 每次赋值都需要更新计数器，伴随着加法和减法操作，增加了时间开销。
- 引用计数器有一个严重的问题，即**无法处理循环引用**的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。

举例说明：

代码如下：

```java
class A {
    private B b;
    public void setB(B b) {
        this.b = b;
    }
}
class B {
    private A a;
    public void setA(A a) {
        this.a = a;
    }
}
public static void method() {
    A a = new A();
    B b = new B();
    a.setB(b);
    b.setA(a);
}
```

图例如下：

![](https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/引用计数法_循环引用1.png)

当创建了A、B两个对象之后，栈中的a和b分别指向了堆中的A和B两个实例，此时这两个实例的引用计数都是1。然后a和b又分别将set了b和a，则此时实例A和B的引用计数就都变成了2。

![](https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/引用计数法_循环引用2.png)

等到方法执行结束之后，栈中的a和b出栈，引用断开，则堆中的A和B的引用计数都会减1，此时A和B的引用计数就都是1，但是从此之后，不会再有其他对象能够引用它们了，并且它们的引用计数不会变为0，无法被垃圾回收，所以就造成了内存泄漏问题。



### 可达性分析算法（根搜索算法）

相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效的解决在引用计数算法中**循环引用**的问题，防止内存泄漏的发生。

#### 基本思路

- 可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）。
- 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。
- 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

#### 哪些是GC Root？

- 虚拟机栈中引用的对象，比如各个线程被调用的方法中使用到的参数、局部变量等。
- 本地方法栈内本地方法引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 所有被同步锁持有的对象。
- Java虚拟机内部的引用，比如基本数据类型对应的Class对象，一些 常驻的异常对象，系统类加载器。
- 反映Java虚拟机内部情况的JMXBean，JVMTI中注册的毁掉、本地方法代码缓存等。
- **特殊情况**：在分代收集和局部回收中，新生代的对象在老年代中也许会存在引用，这是老年代中的对象也可以被算成是GC Root。

## 垃圾回收算法

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。

目前在JVM中比较常见的三种垃圾收集算法是``标记-清除算法（Mark-Sweep）``，``复制算法（Copying）``，``标记-压缩算法（Mark-Compact）``。