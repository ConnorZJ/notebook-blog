---
title: 垃圾回收
date: 2021-01-07
categories:
 - JVM
tags:
 - JVM
---

## 垃圾回收概述

### 什么是垃圾？

在JVM中，垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占用的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致**内存溢出**。

### 为什么需要垃圾回收

1. 对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。
2. 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。
3. 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有垃圾回收就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。

## 垃圾回收算法

在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中**哪些是存活对象，哪些是已经死亡**的对象。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们称之为**垃圾标记阶段**。

那么在JVM中如何标记一个对象是死亡的呢？简单来说，当一个**对象已经不再被任何的存活对象继续引用**时，就可以宣判为已经死亡。

判断对象存活一般有两种方式：**引用计数算法**和**可达性分析算法**。

### 引用计数算法

引用计数算法（Reference Counting），对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。

对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就+1；当引用失效时，引用计数器就-1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可以进行回收。

#### 引用计数算法的优缺点

优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。

缺点：

- 需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
- 每次赋值都需要更新计数器，伴随着加法和减法操作，增加了时间开销。
- 引用计数器有一个严重的问题，即**无法处理循环引用**的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。

举例说明：

代码如下：

```java
class A {
    private B b;
    public void setB(B b) {
        this.b = b;
    }
}
class B {
    private A a;
    public void setA(A a) {
        this.a = a;
    }
}
public static void method() {
    A a = new A();
    B b = new B();
    a.setB(b);
    b.setA(a);
}
```

图例如下：

![](https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/引用计数法_循环引用1.png)

当创建了A、B两个对象之后，栈中的a和b分别指向了堆中的A和B两个实例，此时这两个实例的引用计数都是1。然后a和b又分别将set了b和a，则此时实例A和B的引用计数就都变成了2。

![](https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/引用计数法_循环引用2.png)

等到方法执行结束之后，栈中的a和b出栈，引用断开，则堆中的A和B的引用计数都会减1，此时A和B的引用计数就都是1，但是从此之后，不会再有其他对象能够引用它们了，并且它们的引用计数不会变为0，无法被垃圾回收，所以就造成了内存泄漏问题。