---
title: 垃圾回收
date: 2021-01-07
categories:
 - JVM
tags:
 - JVM
---

## 垃圾回收概述

### 什么是垃圾？

在JVM中，垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占用的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致**内存溢出**。

### 为什么需要垃圾回收

1. 对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。
2. 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。
3. 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有垃圾回收就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。

## 判断垃圾的两种算法

在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中**哪些是存活对象，哪些是已经死亡**的对象。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们称之为**垃圾标记阶段**。

那么在JVM中如何标记一个对象是死亡的呢？简单来说，当一个**对象已经不再被任何的存活对象继续引用**时，就可以宣判为已经死亡。

判断对象存活一般有两种方式：**引用计数算法**和**可达性分析算法**。

### 引用计数算法

引用计数算法（Reference Counting），对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。

对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就+1；当引用失效时，引用计数器就-1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可以进行回收。

#### 引用计数算法的优缺点

优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。

缺点：

- 需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
- 每次赋值都需要更新计数器，伴随着加法和减法操作，增加了时间开销。
- 引用计数器有一个严重的问题，即**无法处理循环引用**的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。

举例说明：

代码如下：

```java
class A {
    private B b;
    public void setB(B b) {
        this.b = b;
    }
}
class B {
    private A a;
    public void setA(A a) {
        this.a = a;
    }
}
public static void method() {
    A a = new A();
    B b = new B();
    a.setB(b);
    b.setA(a);
}
```

图例如下：

![](https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/引用计数法_循环引用1.png)

当创建了A、B两个对象之后，栈中的a和b分别指向了堆中的A和B两个实例，此时这两个实例的引用计数都是1。然后a和b又分别将set了b和a，则此时实例A和B的引用计数就都变成了2。

![](https://connorzj.oss-cn-shenzhen.aliyuncs.com/blog-pic/引用计数法_循环引用2.png)

等到方法执行结束之后，栈中的a和b出栈，引用断开，则堆中的A和B的引用计数都会减1，此时A和B的引用计数就都是1，但是从此之后，不会再有其他对象能够引用它们了，并且它们的引用计数不会变为0，无法被垃圾回收，所以就造成了内存泄漏问题。



### 可达性分析算法（根搜索算法）

相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效的解决在引用计数算法中**循环引用**的问题，防止内存泄漏的发生。

#### 基本思路

- 可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）。
- 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。
- 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

#### 哪些是GC Root？

- 虚拟机栈中引用的对象，比如各个线程被调用的方法中使用到的参数、局部变量等。
- 本地方法栈内本地方法引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 所有被同步锁持有的对象。
- Java虚拟机内部的引用，比如基本数据类型对应的Class对象，一些 常驻的异常对象，系统类加载器。
- 反映Java虚拟机内部情况的JMXBean，JVMTI中注册的毁掉、本地方法代码缓存等。
- **特殊情况**：在分代收集和局部回收中，新生代的对象在老年代中也许会存在引用，这是老年代中的对象也可以被算成是GC Root。

## 垃圾回收算法

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。

目前在JVM中比较常见的三种垃圾收集算法是``标记-清除算法（Mark-Sweep）``，``复制算法（Copying）``，``标记-压缩算法（Mark-Compact）``。

### 标记-清除算法

当堆中的有效内存空间被耗尽的时候，就会停止整个程序，然后进行两项工作，第一项则是标记，第二项则是清除。

标记：垃圾收集器从引用根节点开始遍历，**标记所有被引用的对象**，一般是在对象的Header中记录为可达对象。

清除：垃圾收集器堆对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有标记为可达对象，则对其回收。

> 这里所谓的清除并不是真的置空，而是把需要清理的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，够的话就存放。

#### 缺点

- 效率不高。因为标记的时候可能会进行全部的遍历，而清除的时候会再全部遍历一遍。
- 在进行GC的时候，需要停止整个应用程序，导致用户体验差。
- 这总方式清理出来的空闲内存时不连续的，产生内存碎片。需要维护一个空闲列表。

### 复制算法

将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

#### 优点

- 没有标记和清除的过程，实现简单，运行高效。
- 复制过去以后保证空间的连续性，不会出现碎片问题。

#### 缺点

- 此算法的明显的缺点就是需要使用两倍的内存空间。
- 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。

> 如果系统中的垃圾对象很多，复制算法的效率就不是特别好。因为复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。
>
> 所以对于新生代中的S0区和S1区中，这里面的大部分对象都是朝生夕死的，这种情况非常适合复制算法。

### 标记-压缩算法

第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象。第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。

标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩算法。二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。

标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

#### 优点

- 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
- 消除了复制算法当中，内存减半的高额代价。

#### 缺点

- 从效率上来说，标记-整理算法要低于复制算法。
- 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。
- 移动过程中，需要全程暂停用户应用程序。

### 三种算法对比

|          | 标记-清除算法      | 标记-压缩算法    | 复制算法                              |
| -------- | ------------------ | ---------------- | ------------------------------------- |
| 速度     | 中等               | 最慢             | 最快                                  |
| 空间开销 | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍大小（不堆积碎片） |
| 移动对象 | 否                 | 是               | 是                                    |

从效率上来说，复制算法最快，但是却浪费了太多内存。

而为了尽量兼顾上面提到的三个指标，标记-压缩算法相对来说更平滑一些，但是效率上不尽人意，它比复制算法多了一个标记的阶段，比标记-清理多了一个整理内存的阶段。