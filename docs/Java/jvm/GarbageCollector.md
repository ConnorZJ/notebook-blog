---
title: 垃圾回收器
date: 2021-01-10
categories:
 - JVM
tags:
 - JVM
---

## 垃圾回收的相关概念

### 垃圾回收的并行、串行与并发

并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态

串行（Serial）：相较于并行的概念，单线程执行，如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。

并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序线程运行与另一个CPU上。

### 安全点和安全区域

**安全点**：程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为安全点（SafePoint）。

Safe Point的选择很重要，如果太少可能导致GC等待时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。

> 如果在GC发生时，检查所有线程都跑到了最近的安全点停顿下来呢？
>
> - 抢先式中断（目前没有虚拟机采用）：首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。
> - 主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个表示，如果中断标志为true，则将自己进行中断挂起。

Safe Point机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point。但是，程序“不执行”的时候，例如线程处于sleep状态或阻塞状态，这个时候线程无法响应JVM的中断请求，无法达到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要**安全区域**（Safe Region）来解决。

安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全。我们也可以把Safe Region看做是被扩展了的Safe Point。

> 实际执行：
>
> 1. 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程。
> 2. 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止。

## Java中的几种引用

在Java中，有四种引用，分别是：强引用、软引用、弱引用、虚引用。这四种引用强度依次主键减弱。除了强引用，其他三种引用均可以在``java.lang.ref``包中找到，开发人员可以在应用程序中直接使用它们。

- 强引用（Strong Reference）：最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，即类似``Object obj = new Object()``这种引用关系。**无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。**
- 软引用（Soft Reference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
- 弱引用（Weak Reference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。
- 虚引用（Phantom Reference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

## 垃圾收集器

### Serial收集器/Serial Old收集器——串行回收

Serial收集器是最基本、历史最悠久的垃圾收集器。JDK1.3之前回收新生代唯一的选择。Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。

Serial收集器采用复制算法、串行回收和STW机制的方式执行内存回收。

Serial Old收集器同样采用了串行回收和STW机制，内存回收方式使用的是标记-压缩算法。

Serial的**优势**：**简单而高效**（与其他收集器的单线程比较），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。

在HotSpot虚拟机中，使用``-XX:+UseSerialGC``参数可以指定年轻代和老年代都使用串行收集器，等价于新生代用Serial GC，且老年代用Serial Old GC。

### ParNew收集器——并行回收

如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的**多线程版本**。Par是Parallel的缩写，New是只能处理新生代。

ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、STW机制。

在HotSpot虚拟机中，使用``-XX:+UseParNewGC``手动指定使用ParNew为新生代的垃圾收集器，此处只影响新生代，老年代的收集器不会改变。使用``-XX:ParallelGCThreads=n``限制线程数量，一般默认和CPU的数量相同。

### Parallel Scavenge收集器——高吞吐量

HotSpot的年轻代中出了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样采用了复制算法、并行回收和STW机制。

Parallel Scavenge收集器在JDK1.6时提供了用于执行老年代收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和STW机制。

在HotSpot虚拟机中，使用``-XX:+UseParallelGC``手动指定年轻代使用Parallel并行收集器，使用``+XX:+UseParallelOldGC``手动指定老年代使用Parallel Old并行收集器。在JDK8中，默认使用Parallel和Parallel Old收集器分别进行新生代和老年代的垃圾回收，而且这两个垃圾收集器会**互相激活**，比如显式的指定了使用Parallel Old GC进行老年代的垃圾回收的话，默认也会使用Parallel GC进行新生代的垃圾回收，反之同理。

使用``-XX:ParallelGCThreads=n``设置新生代并行的线程数，在默认情况下，当CPU的数量小于8个的时候，ParallelGCThreads的值等于CPU的数量；但是在CPU的数量大于8的时候，ParallelGCThreads的值等于``3 + ( 5 *  CPU_count / 8 )``。

使用``-XX:MaxGCPauseMillis=n``设置垃圾收集器的最大停顿时间（即STW的时间），单位是毫秒。

使用``-XX:GCTimeRatio=n``设置垃圾收集收件占总时间的比例（=1/(n+1)）。取值范围是（0，100），默认值99，也就是垃圾回收时间不超过1%。

使用``-XX:+UseAdaptiveSizePolicy``设置Parallel Scavenge收集器具有自适应调节策略。在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。