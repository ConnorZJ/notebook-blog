---
title: 垃圾回收器
date: 2021-01-10
categories:
 - JVM
tags:
 - JVM
---

## 垃圾回收的相关概念

### 垃圾回收的并行、串行与并发

并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态

串行（Serial）：相较于并行的概念，单线程执行，如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。

并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序线程运行与另一个CPU上。

### 安全点和安全区域

**安全点**：程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为安全点（SafePoint）。

Safe Point的选择很重要，如果太少可能导致GC等待时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。

> 如果在GC发生时，检查所有线程都跑到了最近的安全点停顿下来呢？
>
> - 抢先式中断（目前没有虚拟机采用）：首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。
> - 主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个表示，如果中断标志为true，则将自己进行中断挂起。

Safe Point机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point。但是，程序“不执行”的时候，例如线程处于sleep状态或阻塞状态，这个时候线程无法响应JVM的中断请求，无法达到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要**安全区域**（Safe Region）来解决。

安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全。我们也可以把Safe Region看做是被扩展了的Safe Point。

> 实际执行：
>
> 1. 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程。
> 2. 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止。

## Java中的几种引用

在Java中，有四种引用，分别是：强引用、软引用、弱引用、虚引用。这四种引用强度依次主键减弱。除了强引用，其他三种引用均可以在``java.lang.ref``包中找到，开发人员可以在应用程序中直接使用它们。

- 强引用（Strong Reference）：最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，即类似``Object obj = new Object()``这种引用关系。**无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。**
- 软引用（Soft Reference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
- 弱引用（Weak Reference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。
- 虚引用（Phantom Reference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

## 垃圾收集器

### Serial收集器/Serial Old收集器——串行回收

Serial收集器是最基本、历史最悠久的垃圾收集器。JDK1.3之前回收新生代唯一的选择。Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。

Serial收集器采用复制算法、串行回收和STW机制的方式执行内存回收。

Serial Old收集器同样采用了串行回收和STW机制，内存回收方式使用的是标记-压缩算法。

Serial的**优势**：**简单而高效**（与其他收集器的单线程比较），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。

在HotSpot虚拟机中，使用``-XX:+UseSerialGC``参数可以指定年轻代和老年代都使用串行收集器，等价于新生代用Serial GC，且老年代用Serial Old GC。

### ParNew收集器——并行回收

如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的**多线程版本**。Par是Parallel的缩写，New是只能处理新生代。

ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、STW机制。

在HotSpot虚拟机中，使用``-XX:+UseParNewGC``手动指定使用ParNew为新生代的垃圾收集器，此处只影响新生代，老年代的收集器不会改变。使用``-XX:ParallelGCThreads=n``限制线程数量，一般默认和CPU的数量相同。

### Parallel Scavenge收集器——高吞吐量

HotSpot的年轻代中出了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样采用了复制算法、并行回收和STW机制。

Parallel Scavenge收集器在JDK1.6时提供了用于执行老年代收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和STW机制。

在HotSpot虚拟机中，使用``-XX:+UseParallelGC``手动指定年轻代使用Parallel并行收集器，使用``+XX:+UseParallelOldGC``手动指定老年代使用Parallel Old并行收集器。在JDK8中，默认使用Parallel和Parallel Old收集器分别进行新生代和老年代的垃圾回收，而且这两个垃圾收集器会**互相激活**，比如显式的指定了使用Parallel Old GC进行老年代的垃圾回收的话，默认也会使用Parallel GC进行新生代的垃圾回收，反之同理。

使用``-XX:ParallelGCThreads=n``设置新生代并行的线程数，在默认情况下，当CPU的数量小于8个的时候，ParallelGCThreads的值等于CPU的数量；但是在CPU的数量大于8的时候，ParallelGCThreads的值等于``3 + ( 5 *  CPU_count / 8 )``。

使用``-XX:MaxGCPauseMillis=n``设置垃圾收集器的最大停顿时间（即STW的时间），单位是毫秒。

使用``-XX:GCTimeRatio=n``设置垃圾收集收件占总时间的比例（=1/(n+1)）。取值范围是（0，100），默认值99，也就是垃圾回收时间不超过1%。

使用``-XX:+UseAdaptiveSizePolicy``设置Parallel Scavenge收集器具有自适应调节策略。在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。

### CMS收集器（Concurrent Mark-Sweep）

CMS收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次是实现了让垃圾收集线程与用户线程同时工作。CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。

CMS的垃圾收集算法采用**垃圾-清除**算法，并且也会STW。

CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。

- 初始标记阶段（Initial-Mark）：在这个阶段中，程序中所有的工作线程都将会因为STW机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记处GC Roots能直接关联的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。
- 并发标记阶段（Concurrent-Mark）：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
- 重新标记阶段（Remark）：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一点，但也远比并发标记阶段的时间短。
- 并发清除阶段（Concurrent-Sweep）：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

CMS的**优点**：

- 并发收集
- 低延迟

CMS的**缺点**：

1. 会产生内存碎片，导师并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。
2. CMS手机去对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
3. CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程时同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。

使用``-XX:+UseConcMarkSweepGC``手动指定使用CMS收集器执行内存回收任务。开启该参数后会自动将``+XX:+UseParNewGC``打开。即：ParNew（新生代）+CMS（老年代）+Serial Old的组合。

使用``-XX:ParallelCMSThreads=n``设置CMS的线程数量。默认启动的线程数是（n+3）/4。

使用``-XX:+UseCmsCompactAtFullCollection``用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。通常与``-XX:CMSFullGCsBeforeCompaction=n``来配合使用，设置在执行多少次Full GC后对内存空间进行压缩整理。

使用``-XX:CMSInitiatingOccupanyFraction=n``设置堆内存使用率的阈值，一旦达到阈值，便开始进行回收。